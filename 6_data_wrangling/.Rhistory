tab_1
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg")) %>% slice(2:)
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg")) %>% slice(,2:)
tab_1 = slice(tab_1, 2:)
tab_1 = slice(tab_1, 2)
tab_1
tab_1 = html_table(nodes[[10]]) %>% select(-X1)
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg"))
tab_1 = tab_1[2:]
tab_1 = slice(tab_1, -2)
tab_1
tab_1 = html_table(nodes[[10]]) %>% select(-X1)
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg"))
tab_1 = slice(tab_1, -1)
tab_1
tab_2
tab_2 = html_table(nodes[[19]]) %>% setNames(c("team", "payroll", "avg")) %>%
slice(-1)
tab_2
combined = full_join(tab_1, tab_2, by = "team")
str(combined)
url <- "https://en.wikipedia.org/w/index.php?title=Opinion_polling_for_the_United_Kingdom_European_Union_membership_referendum&oldid=896735054"
h = read_html(url)
nodes = html_nodes(h, "table")
nodes
html_table(nodes[[1]])
html_table(nodes[[1]], fill = TRUE)
html_table(nodes[[2]], fill = TRUE)
html_table(nodes[[3]], fill = TRUE)
html_table(nodes[[4]], fill = TRUE)
html_table(nodes[[5]], fill = TRUE)
head(html_table(nodes[[5]], fill = TRUE))
library(tidyverse)
library(dslabs)
library(readr)
(.packages())
library(rvest)
source('~/Documents/data_science_program/6_data_wrangling/section_3_string_proc/1_string_parsing.R', echo=TRUE)
library(stringr)
murders_raw$population[1:3]
murders_raw %>% summarize_all(funs(commas))
# str_detect() parses for specified chars
commas = function(x) any(str_detect(x, ","))
murders_raw %>% summarize_all(funs(commas))
# read in raw murders data from Wikipedia
url <- "https://en.wikipedia.org/w/index.php?title=Gun_violence_in_the_United_States_by_state&direction=prev&oldid=810166167"
murders_raw <- read_html(url) %>%
html_node("table") %>%
html_table() %>%
setNames(c("state", "population", "total", "murder_rate"))
# inspect data and column classes
head(murders_raw)
murders_raw %>% summarize_all(funs(commas))
# str_replace_all() replaces chars
test_1 = str_replace_all(murders_raw$population, ",", "")
test_1 = as.numeric(test_1)
test_1
# parse_number() simplifies the above
test_2 = parse_number(murders_raw$population)
identical(test_1, test_2)
murders_new = murders_raw %>% mutate_at(2:3, parse_number)
head(murders_new)
data("heights")
data("reported_heights")
# Find entries where as.numeric() throws an error
reported_heights %>% mutate(new_height = as.numeric(height)) %>%
filter(is.na(new_height)) %>%
head(n=10)
problems = reported_heights %>%
filter(not_inches(height)) %>%
.$height
inches = suppressWarnings(as.numeric(x))
# Function to find heights that cannot be converted to inches
not_inches = function(x, smallest = 50, tallest = 84){
inches = suppressWarnings(as.numeric(x))
ind = is.na(inches) | inches < smallest | inches > tallest
ind
}
problems = reported_heights %>%
filter(not_inches(height)) %>%
.$height
length(problems)
# str_subset() to show entries with "cm"
str_subset(reported_heights$height, "cm")
# Ask which str satisfy pattern
yes = c("180 cm", "70 inches")
no = c("180", "70''")
s = c(yes, no)
str_detect(s, "cm") | str_detect(s, "inches")
# | = "or"
str_detect(s, "cm|inches")
# \\d = any digit 0:9
yes = c("5", "6", "5'10", "5 feet", "4'11")
no = c("", ".", "Five", "six")
s = c(yes, no)
pattern = "\\d"
str_detect(s, pattern)
# str_view() shows the first time digit was found in each value
str_view(s, pattern)
install.packages("htmlwidgets")
# str_view() shows the first time digit was found in each value
str_view(s, pattern)
# str_view_all() shows all matches
str_view_all(s, pattern)
# Character Classes are used to define a series of chars that can be matched
# Char classes defined with []
str_view(s, "[56]")
# Find ranges with "[num-num]"
str_view(s, "[4-7]")
str_view(s, "[a-z]") # looks for all lower-case chars
# Quantifiers: {} specify things like "1 or 2 digits"
# "^\\d{1,2}" finds vals with 1 or 2 digits.
pattern = "^\\d{1,2}$"
str_view(s, pattern)
str_view_all(s, pattern)
yes = c("1", "5", "9", "12")
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
no = c("12 3", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
# Quantifiers: {} specify things like "1 or 2 digits"
# "^\\d{1,2}" finds vals with 1 or 2 digits.
pattern = "^\\d{1,2}"
yes = c("1", "5", "9", "12")
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
# Quantifiers: {} specify things like "1 or 2 digits"
# "^\\d{1,2}" finds vals with 1 or 2 digits.
pattern = "^\\d{1,2}$"
yes = c("1", "5", "9", "12")
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
# Finding strs that contain format num'num"
pattern = "^[4-7]'\\d{1,2}\"$"
problems
# Not all issues were found with the defined pattern
pattern = "^[4-7]'\\d{1,2}\"$"
sum(str_detect(problems, pattern))
source('~/Documents/data_science_program/6_data_wrangling/section_3_string_proc/5_regex_search_replace.R', echo=TRUE)
problems[c(2, 10, 11, 12, 15)] %>% str_view(pattern)
# Problems our initial pattern does not account for:
# Students wrote the words "inches" and "feet"
str_subset(problems, "inches")
# Students represented inches with two ' rather than one "
str_subset(problems, "''")
# A way to address above issues:
# Replace feet/symbols with single ', remove any representations of inches
# So, format is: num'num
# New pattern, w/o inches:
pattern = "^[4-7]'\\d{1,2}$"
# A way to address above issues:
# Replace feet/symbols with single ', remove any representations of inches
# So, format is: num'num
# New pattern, w/o inches:
pattern = "^[4-7]'\\d{1,2}$"
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|\"", "") %>%
str_detect(pattern) %>%
sum
problems
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|''|\"", "") %>%
str_detect(pattern) %>%
sum # Now we have 38 matches instead of 14
str_subset(problems, pattern_2)
# White spaces are represented as "\\s"
# To find entries that have a space b/w feet sym and inch num:
pattern_2 = "^[4-7]'\\s\\d{1,2}\"$"
str_subset(problems, pattern_2)
# * = zero or more instances
# Example:
yes = c("AB", "A1B", "A11B", "A111B", "A1111B")
no = c("A2B", "A21B")
str_detect(yes, "A1*B")
str_detect(no, "A1*B") # FALSE FALSE
# + = once or more
# Example:
data.frame(string = yes,
`*` = str_detect(yes, "A1*B"),
`?` = str_detect(yes, "A1?B"),
`+` = str_detect(yes, "A1+B"))
# + = once or more
# Example:
data.frame(string = yes,
none_or_more = str_detect(yes, "A1*B"),
none_or_once = str_detect(yes, "A1?B"),
once_or_more = str_detect(yes, "A1+B"))
# New pattern:
pattern = "^[4-7]\\s*'\\s*\\d{1,2}\"$"
# New pattern:
pattern = "^[4-7]\\s*'\\s*\\d{1,2}\"$"
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|''|\"", "") %>%
str_detect(pattern) %>%
sum
# New pattern:
pattern = "^[4-7]\\s*'\\s*\\d{1,2}$"
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|''|\"", "") %>%
str_detect(pattern) %>%
sum
source('~/Documents/data_science_program/6_data_wrangling/section_3_string_proc/6_groups_with_regex.R', echo=TRUE)
# str_match() allows us to extract groups
yes = c("5,9", "5,11", "6,", "6,1")
no = c("5'9", ",", "2,8", "6.1.1")
s = c(yes, no)
str_match(s, pattern_with_groups)
# Process to define groups in "num,num":
# First digit b/w 4 and 7: [4-7]
# Second digit none or more digits: \\d*
pattern_without_groups = "^[4-7],\\d*$"
# We want to extract digits from above, so we () around each of the 2 digit "groups"
pattern_with_groups = "^([4-7]),(\\d*)$"
# str_match() allows us to extract groups
yes = c("5,9", "5,11", "6,", "6,1")
no = c("5'9", ",", "2,8", "6.1.1")
s = c(yes, no)
str_match(s, pattern_with_groups)
str_extract(s, pattern_with_groups)
pattern_with_groups = "^([4-7]),(\\d*)$"
yes
no
s   #
str_replace(s, pattern_with_groups, "\\1'\\2")
problems
str_subset(problems, pattern_with_groups) %>% head(10)
str_subset(problems, pattern_with_groups) %>% head()
str_subset(problems, pattern_with_groups)
problems
# Process to define groups in "num,num":
# First digit b/w 4 and 7: [4-7]
# Second digit none or more digits: \\d*
pattern_without_groups = "^[4-7],\\d*$"
# We want to extract digits from above, so we () around each of the 2 digit "groups"
pattern_with_groups = "^([4-7]),(\\d*)$"
# str_match() allows us to extract groups
yes = c("5,9", "5,11", "6,", "6,1")
no = c("5'9", ",", "2,8", "6.1.1")
s = c(yes, no)
str_match(s, pattern_with_groups)
str_extract(s, pattern_with_groups)
# Example: converting num,num to num'num
pattern_with_groups = "^([4-7]),(\\d*)$"
yes # "5,9"   "5,11"  "6,"   "6,1"
no  # "5'9"   ","   "2,8"   "6.1.1"
s   # "5,9"   "5,11"   "6,"   "6,1"    "5'9"   ","   "2,8"  "6.1.1"
str_replace(s, pattern_with_groups, "\\1'\\2")
# Our pattern should, thus, now be:
pattern_with_groups = "^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$"
str_subset(problems, pattern_with_groups)
str_subset(problems, pattern_with_groups) %>%
str_replace(pattern_with_groups, "\\1'\\2")
# \\d = any digit 0:9
yes = c("5", "6", "5'10", "5 feet", "4'11")
no = c("", ".", "Five", "six")
s = c(yes, no)
pattern = "\\d"
# str_view() shows the first time digit was found in each value
str_view(s, pattern)
# str_view_all() shows all matches
str_view_all(s, pattern)
str_view(s, "[a-z]") # looks for the first lower-case chars from every val
source('~/Documents/data-science-cert-journey/6_data_wrangling/section_3_string_proc/7_separate_with_regex.R', echo=TRUE)
# Simple example of formatted vals
s = c("5'10", "6,1")
tab = data.frame(x = s)
tab
tab %>% separate(x, c("feet", "inches"), sep = "'")
# Simple example using vals in desired format
s = c("5'10", "6'1")
tab = data.frame(x = s)
tab %>% separate(x, c("feet", "inches"), sep = "'")
# Equivalent code:
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)(\\d{1,2})$")
# Equivalent code:
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)'(\\d{1,2})$")
# Regex is preferred over separate() because it allows for more flexibility
s = c("5'10", "6'1\"", "5'8inches")
tab = data.frame(x = s)
tab
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)'\\(d{1,2})[\"a-z]*$")
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)'(\\d{1,2})[\"a-z]*$")
# Prof.'s regex
tab %>% extract(x, c("feet", "inches"), regex = "(\\d)'(\\d{1,2})")
source('~/Documents/data-science-cert-journey/6_data_wrangling/section_3_string_proc/8_using_groups_and_quantifiers.R', echo=TRUE)
# 1
# Append ' 0
yes = c("5", "6", "7")
no = c("5'", "5''", "5'4")
s = c(yes, no)
str_replace(s, "^([4-7])$", "\\1'0") # Detects entries that begin (^) w/ 4-7, and then end ($)
# 2
# Adapt above regex to detect one or none ('). This will allow us to include entries from case 2.
yes = c("5'", "6", "6'")
no = c("5'4", "6 '")
s = c(yes, no)
str_replace(s, "^([4-7])'?$", "\\1'0")
source('~/Documents/data-science-cert-journey/6_data_wrangling/section_3_string_proc/8_using_groups_and_quantifiers.R', echo=TRUE)
# 2. Problem: Defined pattern requires inches be included to be detected, some entries only have ft.
#    Solution: Adapt above regex to detect one or none ('). This will allow us to include entries from case 2.
yes = c("5'", "6", "6'")
no = c("4'", "5'4", "7'")
s = c(yes, no)
# We only count entries that have either 5 or 6 because we assume that entries above or below were entered in error.
str_replace(s, "^([56])'?$", "\\1'0")
# 3. Problem: Entries included decimal points for inches. Our pattern as defined only looked for 1 to 2 digits for inches
#    Solution: Allow second digit to have decimals using quantifiers
yes = c("4'7.5", "5'9.3", "6'")
no = c("4.3'7", "5.10", "6' 7.3")
s = c(yes, no)
str_replace(s, "^([4-7])'?(\\d?\\d?.?\\d{1,2}?)", "\\1'\\2")
str_replace(s, "^([4-7])'?(\\d?\\d?.?\\d{1,2}?)", "\\1'\\2|0")
# 3. Problem: Entries included decimal points for inches. Our pattern as defined only looked for 1 to 2 digits for inches
#    Solution: Allow second digit to have decimals using quantifiers
yes = c("4'7.5", "5'9.3", "6'5765765")
no = c("4.3'7", "5.10", "6' 7.3")
s = c(yes, no)
str_replace(s, "^[4-7]'(\\d+\\.?\\d*)$", "\\1")
# 2. Problem: Defined pattern requires inches be included to be detected, some entries only have ft.
#    Solution: Adapt above regex to detect one or none ('). This will allow us to include entries from case 2.
yes = c("5'", "6 ", "6'")
no = c("4'", "5'4", "7'")
s = c(yes, no)
# We only count entries that have either 5 or 6 because we assume that entries above or below were entered in error.
str_replace(s, "^([56])'?$", "\\1'0")
# We only count entries that have either 5 or 6 because we assume that entries above or below were entered in error.
str_replace(s, "^([56])\\s*'?$", "\\1'0")
# 5. Problem: Entries in meters, some of which use euro notation for decimals
#    Solution: Define pattern to detect "," b/w 1st and 2nd digit (w/ optional spaces)
yes = c("1,7", "1 ,8", "2, ")
no = c("5,8", "5,3,2", "1.7")
s = c(yes, no)
str_replace(s, "^([1,2])\\s*,\\s*(\\d*)$", "\\1\\.\\2")
# 6 & 7. Problem: Non-numeric entries
#        Solution: Trim spaces and use to_upper or to_lower to standardize words for easier conversion
# Trim spaces w/ str_trim()
s = "4 ' 7 "
str_trim(s)
# Use to_lower() to standardize strs
s = "Five feet eleven inches"
str_to_lower(s)
convert_format = function(s) {
s %>%
str_replace("feet|foot|ft", "'") %>% # Replace feet units w/ syms
str_replace_all("inches|in|''|\"|cm|and", "") %>% # Remove trailing units
str_replace("^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$", "\\1'\\2") %>% # Replace "num,num", "num.num", "num num" formats with "num'num"
str_replace("^([56])'?$", "\\1'0") %>% # add 0 when just 5 or 6
str_replace("^([1,2])\\s*,\\s*(\\d*)$", "\\1\\.\\2") %>% # Replace euro decimal with "." for entries in meters
str_trim() # Remove extra spaces from the ends of strs
}
# Second func converts word entries to numbers (NOTE: This way is not recommended, we will learn better ways to do this later)
words_to_numbers = function(s) {
str_to_lower(s) %>% # Standardize all strs
str_replace_all("zero", "0") %>%
str_replace_all("one", "1") %>%
str_replace_all("two", "2") %>%
str_replace_all("three", "3") %>%
str_replace_all("four", "4") %>%
str_replace_all("five", "5") %>%
str_replace_all("six", "6") %>%
str_replace_all("seven", "7") %>%
str_replace_all("eight", "8") %>%
str_replace_all("nine", "9") %>%
str_replace_all("ten", "10") %>%
str_replace_all("eleven", "11")
}
converted = problems %>% words_to_numbers %>% convert_format
remaining_problems = converted[not_inches_or_cm(converted)]
remaining_problems = converted[not_inches(converted)]
remaining_problems
pattern = "^[4-7]\\s*'\\s*\\d+\\.?\\d*$"
index = str_detect(remaining_problems, pattern)
remaining_problems[!index]
pattern = "^([4-7])\\s*'\\s*(\\d+\\.?\\d*)$"
pattern = "^([4-7])\\s*'\\s*(\\d+\\.?\\d*)$"
smallest = 50
tallest = 84
new_heights = reported_heights %>%
mutate(original = height,
height = words_to_numbers(height) %>% convert_format()) %>%
extract(height, c("feet", "inches"), regex = pattern, remove = FALSE) %>%
mutate_at(c("height", "feet", "inches"), as.numeric) %>%
mutate(guess = 12*feet + inches) %>%
mutate(height = case_when(
!is.na(height) & between(height, smallest, tallest) ~ height, # Inches
!is.na(height) & between(height / 2.54, smallest, tallest) ~ height / 2.54, # Centimeters
!is.na(height) & between(height * 100 / 2.54, smallest, tallest) ~ height * 100 / 2.54, # Meters
!is.na(guess) & inches < 12 & between(guess, smallest, tallest) ~ guess, # feet'inches
TRUE ~ as.numeric(NA))) %>%
select(~guess)
`rlang::last_error()`
rlang::last_error()
new_heights = reported_heights %>%
mutate(original = height,
height = words_to_numbers(height) %>% convert_format()) %>%
extract(height, c("feet", "inches"), regex = pattern, remove = FALSE) %>%
mutate_at(c("height", "feet", "inches"), as.numeric) %>%
mutate(guess = 12*feet + inches) %>%
mutate(height = case_when(
!is.na(height) & between(height, smallest, tallest) ~ height, # Inches
!is.na(height) & between(height / 2.54, smallest, tallest) ~ height / 2.54, # Centimeters
!is.na(height) & between(height * 100 / 2.54, smallest, tallest) ~ height * 100 / 2.54, # Meters
!is.na(guess) & inches < 12 & between(guess, smallest, tallest) ~ guess, # feet'inches
TRUE ~ as.numeric(NA))) %>%
select(-guess)
new_heights %>%
filter(not_inches(original)) %>%
select(original, height) %>%
arrange(height) %>%
View()
new_heights %>% arrange(height) %>% head(n=7)
new_heights %>% arrange(height) %>% head(n=20)
new_heights %>% arrange(height) %>% head(n=50)
filename = system.file("extdata/murders.csv", package = "dslabs")
lines = readlines(filename)
lines = readLines(filename)
lines %>% head() # We can see that csv gets converted to a vector of strs, line by line
source('~/Documents/data-science-cert-journey/6_data_wrangling/section_3_string_proc/9_string_splitting.R', echo=TRUE)
source('~/Documents/data-science-cert-journey/6_data_wrangling/section_3_string_proc/9_string_splitting.R', echo=TRUE)
# str_split() allows us to extract vals with a delimiter
x = str_split(lines, ",")
x %>% head()
lines %>% head() # We can see that csv gets converted to a vector of strs, line by line
lines %>% head() # We can see that csv gets converted to a vector of strs, line by line
(.packages())
# map() applies the same func to each element in a list
library(purrr)
map(x, function(y) y[1]) %>% head()
dat = data.frame(map_chr(x, 1),
map_chr(x, 2),
map_chr(x, 3),
map_chr(x, 4),
map_chr(x, 5)) %>%
mutate_all(parse_guess) %>% # Parses vector and guesses datatype
setNames(col_names)
dat %>% head()
col_names = x[[1]] # First entry has col names
x = x[-1] # remove col names from data
# map() applies the same func to each element in a list
library(purrr) # Located in purrr lib
map(x, function(y) y[1]) %>% head() # Extracts first entry of each element in x
# More efficient way to do the above:
map(x, 1) %>% head()
dat = data.frame(map_chr(x, 1),
map_chr(x, 2),
map_chr(x, 3),
map_chr(x, 4),
map_chr(x, 5)) %>%
mutate_all(parse_guess) %>% # Parses vector and guesses datatype
setNames(col_names)
dat = data.frame(map_chr(x, 1),
map_chr(x, 2),
map_int(x, 3),
map_int(x, 4),
map_int(x, 5)) %>%
mutate_all(parse_guess) %>% # Parses vector and guesses datatype
setNames(col_names)
filename = system.file("extdata/murders.csv", package = "dslabs")
lines = readLines(filename)
lines %>% head() # We can see that csv gets converted to a vector of strs, line by line
# str_split() allows us to extract vals with a delimiter
x = str_split(lines, ",")
x %>% head()
col_names = x[[1]] # First entry has col names
x = x[-1] # remove col names from data
# map() applies the same func to each element in a list
library(purrr) # Located in purrr lib
map(x, function(y) y[1]) %>% head() # Extracts first entry of each element in x
# More efficient way to do the above:
map(x, 1) %>% head()
dat = data.frame(map_chr(x, 1),
map_chr(x, 2),
map_int(x, 3),
map_int(x, 4),
map_int(x, 5)) %>%
mutate_all(parse_guess) %>% # Parses vector and guesses datatype
setNames(col_names)
dat = data.frame(map_chr(x, 1),
map_chr(x, 2),
map_chr(x, 3),
map_chr(x, 4),
map_chr(x, 5)) %>%
mutate_all(parse_guess) %>% # Parses vector and guesses datatype
setNames(col_names)
map_chr(x, 1)
map_chr(x, 2)
map_chr(x, 3)
map_chr(x, 4)
map_chr(x, 4) %>% parse_guess()
map_chr(x, 5) %>% parse_guess()
map_chr(x, 2) %>% parse_guess()
map_chr(x, 3) %>% parse_guess()
map_chr(x, 1) %>% parse_guess()
dat = data.frame(map_chr(x, 1),
map_chr(x, 2),
map_chr(x, 3),
map_chr(x, 4),
map_chr(x, 5)) %>%
mutate_all(parse_guess()) %>% # Parses vector and guesses datatype
setNames(col_names)
x
