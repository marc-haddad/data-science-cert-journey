# Best Attempt:
dat %>% separate(key, c("year", "variable_name"), sep = "_", extra = "merge")
# Fourth Attempt:
# Now we need to create a col for each var instead of both in 1 col
dat %>% separate(key, c("year", "variable_name"), sep = "_", extra = "merge") %>%
spread(variable_name, value) # Expands var_name by its val.
source('~/.active-rstudio-document', echo=TRUE)
force(co2)
co2_wide <- data.frame(matrix(co2, ncol = 12, byrow = TRUE)) %>%
setNames(1:12) %>%
mutate(year = as.character(1959:1997))
View(co2_wide)
co2_tidy <- gather(co2_wide,month,co2,-year)
View(co2_tidy)
co2_tidy %>% ggplot(aes(as.numeric(month), co2, color = year)) + geom_line()
data(admissions)
head(admissions)
dat <- admissions %>% select(-applicants)
dat
dat_tidy <- spread(dat, gender, admitted)
tmp <- gather(admissions, key, value, admitted:applicants)
tmp
tmp2 <- unite(tmp, column_name, c(key, gender))
tmp2
data("murders")
data("polls_us_election_2016")
head(results_us_election_2016)
head(results_us_election_2016)
data("murders")
data("polls_us_election_2016")
head(results_us_election_2016)
library(dslabs)
data("murders")
data("polls_us_election_2016")
head(results_us_election_2016)
head(murders)
data("polls_us_election_2016")
head(results_us_election_2016)
library(tidyverse)
tab = left_join(murders, results_us_election_2016, by =  "state")
head(tab)
library(ggrepel)
tab %>% ggplot(aes(population/10^6, electoral_votes, label = abb)) +
geom_point() +
geom_text_repel() +
scale_x_continuous(trans = 'log2') +
scale_y_continuous(trans = "log2") +
geom_smooth(method = "lm", se = FALSE)
tab1 = slice(murders, 1:6) %>% select(state, population)
tab1
tab2 = slice(results_us_election_2016, c(1:3, 5, 7:8)) %>%
select(state, electoral_votes)
tab2
slice(results_us_election_2016, c(4, 6))
slice(results_us_election_2016, c(4:6))
slice(results_us_election_2016, c(1:8))
tab2
# left_join()
left_join(tab1, tab2)
tab1 = slice(murders, 1:6) %>% select(state, population)
tab1
tab2 = slice(results_us_election_2016, c(1:3, 5, 7:8)) %>%
select(state, electoral_votes)
tab2
# left_join()
left_join(tab1, tab2)
library(dslabs)
library(tidyverse)
library(ggrepel)
tab1 = slice(murders, 1:6) %>% select(state, population)
tab1
tab2 = slice(results_us_election_2016, c(1:3, 5, 7:8)) %>%
select(state, electoral_votes)
tab2
# left_join()
left_join(tab1, tab2)
tab1 %>% left_join(tab2) # Alt.
# Binding
# Combines cols into a tibble
bind_cols(a = 1:3, b = 4:5)
# Binding
# Combines cols into a tibble
bind_cols(a = 1:3, b = 4:6)
# bind_cols() also combines DFs
tab
# bind_cols() also combines DFs
tab1 = tab[,1:3]
tab1
# bind_cols() also combines DFs
tab1 = tab[1:3]
tab1
# bind_cols() also combines DFs
tab1 = tab[5:12,1:3]
tab1
# bind_cols() also combines DFs
tab1 = tab[,1:3]
tab1
new_tab = bind_cols(tab1, tab2, tab3)
head(new_tab)
tab3 = tab[, 7:9]
new_tab = bind_cols(tab1, tab2, tab3)
# bind_cols() also combines DFs
tab1 = tab[, 1:3]
tab2 = tab[, 4:6]
tab3 = tab[, 7:9]
new_tab = bind_cols(tab1, tab2, tab3)
head(new_tab)
# bind_rows() combines rows
tab1 = tab[1:2,]
tab2 = tab[3:4,]
bind_rows(tab1, tab2)
library(tidyverse)
# intersect() takes intersection of vectors, DFs
tab1 = tab[1:5,]
tab2 = tab[3:7,]
intersect(tab1, tab2)
# union() takes the union of unique vals in vectors, DFs
union(1:10, 6:15)
union(tab1, tab2)
# intersect() takes intersection of vectors, DFs
tab1 = tab[1:5,]
tab2 = tab[3:7,]
intersect(tab1, tab2) # Returns rows 3:5
# setdiff() returns the diffs b/w vectors, DFs. NOT SYMETRIC
setdiff(1:10, 6:15)
setdiff(6:15, 1:10)
setdiff(tab1, tab2)
tab1
tab2
# setequal() tells us if sets are equal REGARDLESS OF ORDER
setequal(1:5, 5:1)
# Much more useful for tables
setequal(tab1, tab2)
# Much more useful for tables
print(setequal(tab1, tab2))
library(dslabs)
library(tidyverse)
library(ggrepel)
# Much more useful for tables
setequal(tab1, tab2)
install.packages("Lahman")
library(Lahman)
source('~/.active-rstudio-document', echo=TRUE)
Master %>% as_tibble()
top_names <- top %>% left_join(Master) %>%
select(playerID, nameFirst, nameLast, HR)
top_names
top_salary <- Salaries %>% filter(yearID == 2016) %>%
%>%
select(nameFirst, nameLast, teamID, HR, salary)
head(Salaries)
top_salary <- Salaries %>% filter(yearID == 2016) %>%
right_join(top_names) %>%
select(nameFirst, nameLast, teamID, HR, salary)
top_salary
head(AwardsPlayers)
AwardsPlayers
inner_join(top, AwardsPlayers)
union(top, AwardsPlayers)
setdiff(top, AwardsPlayers)
intersect(top, AwardsPlayers)
awards_2016 = AwardsPlayers %>% filter(yearID == 2016)
awards_2016
intersect(top["playerID"], awards_2016["playerID"])
setdiff(awards_2016["playerID"], top["playerID"])
install.packages("rvest")
install.packages("rvest")
url = "http://en.wikipedia.org/wiki/Murder_in_the_United_States_by_state"
library(tidyverse)
url = "http://en.wikipedia.org/wiki/Murder_in_the_United_States_by_state"
h = read_html(url)
library(readr)
url = "http://en.wikipedia.org/wiki/Murder_in_the_United_States_by_state"
h = read_html(url)
library(textreadr)
library(rvest)
h = read_html(url)
class(h)
tab = h %>% html_nodes("table")
tab = tab[[2]]
tab
# html_table() converts html to DF
html_table(tab)
# Or
tab = tab %>% html_table
tab
# Or
tab = tab %>% html_table()
tab = h %>% html_nodes("table")
tab = tab[[2]]
tab
# Or
tab = tab %>% html_table()
tab
class(tab)
tab = tab %>% setNames(c("state", "population", "total", "murders", "gun_murders", "gun_ownership"
, "total_rate", "murder_rate", "gun_murder_rate"))
head(tab)
source('~/Documents/data_science_program/6_data_wrangling/10_scrape_assessment.R', echo=TRUE)
nodes = html_nodes(h, "table")
html_text(nodes[[8]])
html_table(nodes[[8]])
html_table(nodes[[1:4]])
html_table(nodes[[1]])
html_table(nodes[[c(1:4)]])
html_table(nodes[[1]])
html_table(nodes[[2]])
html_table(nodes[[3]])
html_table(nodes[[4]])
tab_1 = html_table(nodes[[10]])
tab_2 = html_table(nodes[[19]])
tab_1
tab_2
tab_1 = html_table(nodes[[10]]) %>% select(-X1)
tab_1
tab_1 = tab_1 %>% setNames(X2 = "team", X3 = "payroll", X4 = "avg")
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg"))
tab_1
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg")) %>% slice(2:)
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg")) %>% slice(,2:)
tab_1 = slice(tab_1, 2:)
tab_1 = slice(tab_1, 2)
tab_1
tab_1 = html_table(nodes[[10]]) %>% select(-X1)
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg"))
tab_1 = tab_1[2:]
tab_1 = slice(tab_1, -2)
tab_1
tab_1 = html_table(nodes[[10]]) %>% select(-X1)
tab_1 = tab_1 %>% setNames(c("team", "payroll", "avg"))
tab_1 = slice(tab_1, -1)
tab_1
tab_2
tab_2 = html_table(nodes[[19]]) %>% setNames(c("team", "payroll", "avg")) %>%
slice(-1)
tab_2
combined = full_join(tab_1, tab_2, by = "team")
str(combined)
url <- "https://en.wikipedia.org/w/index.php?title=Opinion_polling_for_the_United_Kingdom_European_Union_membership_referendum&oldid=896735054"
h = read_html(url)
nodes = html_nodes(h, "table")
nodes
html_table(nodes[[1]])
html_table(nodes[[1]], fill = TRUE)
html_table(nodes[[2]], fill = TRUE)
html_table(nodes[[3]], fill = TRUE)
html_table(nodes[[4]], fill = TRUE)
html_table(nodes[[5]], fill = TRUE)
head(html_table(nodes[[5]], fill = TRUE))
library(tidyverse)
library(dslabs)
library(readr)
(.packages())
library(rvest)
source('~/Documents/data_science_program/6_data_wrangling/section_3_string_proc/1_string_parsing.R', echo=TRUE)
library(stringr)
murders_raw$population[1:3]
murders_raw %>% summarize_all(funs(commas))
# str_detect() parses for specified chars
commas = function(x) any(str_detect(x, ","))
murders_raw %>% summarize_all(funs(commas))
# read in raw murders data from Wikipedia
url <- "https://en.wikipedia.org/w/index.php?title=Gun_violence_in_the_United_States_by_state&direction=prev&oldid=810166167"
murders_raw <- read_html(url) %>%
html_node("table") %>%
html_table() %>%
setNames(c("state", "population", "total", "murder_rate"))
# inspect data and column classes
head(murders_raw)
murders_raw %>% summarize_all(funs(commas))
# str_replace_all() replaces chars
test_1 = str_replace_all(murders_raw$population, ",", "")
test_1 = as.numeric(test_1)
test_1
# parse_number() simplifies the above
test_2 = parse_number(murders_raw$population)
identical(test_1, test_2)
murders_new = murders_raw %>% mutate_at(2:3, parse_number)
head(murders_new)
data("heights")
data("reported_heights")
# Find entries where as.numeric() throws an error
reported_heights %>% mutate(new_height = as.numeric(height)) %>%
filter(is.na(new_height)) %>%
head(n=10)
problems = reported_heights %>%
filter(not_inches(height)) %>%
.$height
inches = suppressWarnings(as.numeric(x))
# Function to find heights that cannot be converted to inches
not_inches = function(x, smallest = 50, tallest = 84){
inches = suppressWarnings(as.numeric(x))
ind = is.na(inches) | inches < smallest | inches > tallest
ind
}
problems = reported_heights %>%
filter(not_inches(height)) %>%
.$height
length(problems)
# str_subset() to show entries with "cm"
str_subset(reported_heights$height, "cm")
# Ask which str satisfy pattern
yes = c("180 cm", "70 inches")
no = c("180", "70''")
s = c(yes, no)
str_detect(s, "cm") | str_detect(s, "inches")
# | = "or"
str_detect(s, "cm|inches")
# \\d = any digit 0:9
yes = c("5", "6", "5'10", "5 feet", "4'11")
no = c("", ".", "Five", "six")
s = c(yes, no)
pattern = "\\d"
str_detect(s, pattern)
# str_view() shows the first time digit was found in each value
str_view(s, pattern)
install.packages("htmlwidgets")
# str_view() shows the first time digit was found in each value
str_view(s, pattern)
# str_view_all() shows all matches
str_view_all(s, pattern)
# Character Classes are used to define a series of chars that can be matched
# Char classes defined with []
str_view(s, "[56]")
# Find ranges with "[num-num]"
str_view(s, "[4-7]")
str_view(s, "[a-z]") # looks for all lower-case chars
# Quantifiers: {} specify things like "1 or 2 digits"
# "^\\d{1,2}" finds vals with 1 or 2 digits.
pattern = "^\\d{1,2}$"
str_view(s, pattern)
str_view_all(s, pattern)
yes = c("1", "5", "9", "12")
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
no = c("12 3", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
# Quantifiers: {} specify things like "1 or 2 digits"
# "^\\d{1,2}" finds vals with 1 or 2 digits.
pattern = "^\\d{1,2}"
yes = c("1", "5", "9", "12")
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
# Quantifiers: {} specify things like "1 or 2 digits"
# "^\\d{1,2}" finds vals with 1 or 2 digits.
pattern = "^\\d{1,2}$"
yes = c("1", "5", "9", "12")
no = c("123", "a4", "b")
s = c(yes, no)
str_view(s, pattern)
# Finding strs that contain format num'num"
pattern = "^[4-7]'\\d{1,2}\"$"
problems
# Not all issues were found with the defined pattern
pattern = "^[4-7]'\\d{1,2}\"$"
sum(str_detect(problems, pattern))
source('~/Documents/data_science_program/6_data_wrangling/section_3_string_proc/5_regex_search_replace.R', echo=TRUE)
problems[c(2, 10, 11, 12, 15)] %>% str_view(pattern)
# Problems our initial pattern does not account for:
# Students wrote the words "inches" and "feet"
str_subset(problems, "inches")
# Students represented inches with two ' rather than one "
str_subset(problems, "''")
# A way to address above issues:
# Replace feet/symbols with single ', remove any representations of inches
# So, format is: num'num
# New pattern, w/o inches:
pattern = "^[4-7]'\\d{1,2}$"
# A way to address above issues:
# Replace feet/symbols with single ', remove any representations of inches
# So, format is: num'num
# New pattern, w/o inches:
pattern = "^[4-7]'\\d{1,2}$"
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|\"", "") %>%
str_detect(pattern) %>%
sum
problems
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|''|\"", "") %>%
str_detect(pattern) %>%
sum # Now we have 38 matches instead of 14
str_subset(problems, pattern_2)
# White spaces are represented as "\\s"
# To find entries that have a space b/w feet sym and inch num:
pattern_2 = "^[4-7]'\\s\\d{1,2}\"$"
str_subset(problems, pattern_2)
# * = zero or more instances
# Example:
yes = c("AB", "A1B", "A11B", "A111B", "A1111B")
no = c("A2B", "A21B")
str_detect(yes, "A1*B")
str_detect(no, "A1*B") # FALSE FALSE
# + = once or more
# Example:
data.frame(string = yes,
`*` = str_detect(yes, "A1*B"),
`?` = str_detect(yes, "A1?B"),
`+` = str_detect(yes, "A1+B"))
# + = once or more
# Example:
data.frame(string = yes,
none_or_more = str_detect(yes, "A1*B"),
none_or_once = str_detect(yes, "A1?B"),
once_or_more = str_detect(yes, "A1+B"))
# New pattern:
pattern = "^[4-7]\\s*'\\s*\\d{1,2}\"$"
# New pattern:
pattern = "^[4-7]\\s*'\\s*\\d{1,2}\"$"
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|''|\"", "") %>%
str_detect(pattern) %>%
sum
# New pattern:
pattern = "^[4-7]\\s*'\\s*\\d{1,2}$"
problems %>%
str_replace("feet|ft|foot", "'") %>%
str_replace("inches|in|''|\"", "") %>%
str_detect(pattern) %>%
sum
source('~/Documents/data_science_program/6_data_wrangling/section_3_string_proc/6_groups_with_regex.R', echo=TRUE)
# str_match() allows us to extract groups
yes = c("5,9", "5,11", "6,", "6,1")
no = c("5'9", ",", "2,8", "6.1.1")
s = c(yes, no)
str_match(s, pattern_with_groups)
# Process to define groups in "num,num":
# First digit b/w 4 and 7: [4-7]
# Second digit none or more digits: \\d*
pattern_without_groups = "^[4-7],\\d*$"
# We want to extract digits from above, so we () around each of the 2 digit "groups"
pattern_with_groups = "^([4-7]),(\\d*)$"
# str_match() allows us to extract groups
yes = c("5,9", "5,11", "6,", "6,1")
no = c("5'9", ",", "2,8", "6.1.1")
s = c(yes, no)
str_match(s, pattern_with_groups)
str_extract(s, pattern_with_groups)
pattern_with_groups = "^([4-7]),(\\d*)$"
yes
no
s   #
str_replace(s, pattern_with_groups, "\\1'\\2")
problems
str_subset(problems, pattern_with_groups) %>% head(10)
str_subset(problems, pattern_with_groups) %>% head()
str_subset(problems, pattern_with_groups)
problems
# Process to define groups in "num,num":
# First digit b/w 4 and 7: [4-7]
# Second digit none or more digits: \\d*
pattern_without_groups = "^[4-7],\\d*$"
# We want to extract digits from above, so we () around each of the 2 digit "groups"
pattern_with_groups = "^([4-7]),(\\d*)$"
# str_match() allows us to extract groups
yes = c("5,9", "5,11", "6,", "6,1")
no = c("5'9", ",", "2,8", "6.1.1")
s = c(yes, no)
str_match(s, pattern_with_groups)
str_extract(s, pattern_with_groups)
# Example: converting num,num to num'num
pattern_with_groups = "^([4-7]),(\\d*)$"
yes # "5,9"   "5,11"  "6,"   "6,1"
no  # "5'9"   ","   "2,8"   "6.1.1"
s   # "5,9"   "5,11"   "6,"   "6,1"    "5'9"   ","   "2,8"  "6.1.1"
str_replace(s, pattern_with_groups, "\\1'\\2")
# Our pattern should, thus, now be:
pattern_with_groups = "^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$"
str_subset(problems, pattern_with_groups)
str_subset(problems, pattern_with_groups) %>%
str_replace(pattern_with_groups, "\\1'\\2")
# \\d = any digit 0:9
yes = c("5", "6", "5'10", "5 feet", "4'11")
no = c("", ".", "Five", "six")
s = c(yes, no)
pattern = "\\d"
# str_view() shows the first time digit was found in each value
str_view(s, pattern)
# str_view_all() shows all matches
str_view_all(s, pattern)
str_view(s, "[a-z]") # looks for the first lower-case chars from every val
source('~/Documents/data-science-cert-journey/6_data_wrangling/section_3_string_proc/7_separate_with_regex.R', echo=TRUE)
# Simple example of formatted vals
s = c("5'10", "6,1")
tab = data.frame(x = s)
tab
tab %>% separate(x, c("feet", "inches"), sep = "'")
# Simple example using vals in desired format
s = c("5'10", "6'1")
tab = data.frame(x = s)
tab %>% separate(x, c("feet", "inches"), sep = "'")
# Equivalent code:
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)(\\d{1,2})$")
# Equivalent code:
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)'(\\d{1,2})$")
# Regex is preferred over separate() because it allows for more flexibility
s = c("5'10", "6'1\"", "5'8inches")
tab = data.frame(x = s)
tab
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)'\\(d{1,2})[\"a-z]*$")
tab %>% extract(x, c("feet", "inches"), regex = "^(\\d)'(\\d{1,2})[\"a-z]*$")
# Prof.'s regex
tab %>% extract(x, c("feet", "inches"), regex = "(\\d)'(\\d{1,2})")
